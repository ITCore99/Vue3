{"code":"import { isArray, isIntegerKey } from \"@vue/shared\";\r\n/**\r\n * effect 副作用函数\r\n * 注意effect不仅仅只有一个参数 它还有第二个参数\r\n * effect是响应式的可以做到数据变化 effect 重新执行\r\n */\r\nfunction effect(fn, options = {}) {\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) { // lazy 属性为true 说明这个effect 是懒执行的\r\n        effect(); // 默认先执行一次 \r\n    }\r\n    return effect;\r\n}\r\nlet uid = 0;\r\nlet activeEffect = null; // 存储当前正在执行的effect\r\nconst effectStack = []; // 解决嵌套effect 出现依赖收集错误的问题\r\n// 创建一个响应式的effect 作用是对effect进行二次的处理 添加一些标识\r\nfunction createReactiveEffect(fn, options) {\r\n    const reactiveEffect = function () {\r\n        if (!effectStack.includes(reactiveEffect)) {\r\n            try {\r\n                effectStack.push(reactiveEffect);\r\n                activeEffect = reactiveEffect;\r\n                return fn(); // 进行依赖的收集\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    reactiveEffect.id = uid++; // effect标识 执行更新的时候用此标识对effect进行排序\r\n    reactiveEffect._isEffect = true; // 用于标识这是一个effect\r\n    reactiveEffect.raw = fn; // 保存原始的fn函数\r\n    reactiveEffect.options = options; // 保存options配置项 注意这里会保存computed的scheduler\r\n    return reactiveEffect;\r\n}\r\nconst targetMap = new WeakMap();\r\n// 进行依赖收集 operator 是一个标识\r\nfunction track(target, type, key) {\r\n    if (!activeEffect)\r\n        return;\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let deps = depsMap.get(key);\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()));\r\n    }\r\n    if (!deps.has(activeEffect)) {\r\n        deps.add(activeEffect);\r\n    }\r\n}\r\n/**\r\n * effect(() => { // effect1\r\n *  state.name ==> effect1\r\n *  effect(() => { // effect2\r\n *    state.age ==> effect2\r\n *  })\r\n *  state.address ==> effect2 这依赖收集出现了错误\r\n * })\r\n */\r\n// 触发更新\r\nfunction trigger(target, type, key, value, oldvalue) {\r\n    // 如果这个属性没有收集过effect 则不需要任何的更新\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap)\r\n        return;\r\n    // 将所有收集的effect 全部存在一个新的集合中(主要是对数组的lenth和下标effect整合) 最后在一起执行(使用set对effect进行去重)\r\n    const effects = new Set();\r\n    // 需要判断是不是修改的数组的长度 因为数组的长度影响比较大(就是当我们把数组的长度由100变为1 之前也收集了下标为3的依赖 \r\n    // 那我们不仅要执行length的依赖也要执行下标为3的依赖)\r\n    if (isArray(target) && key === 'length') { // 如果更改的长度小于收集的索引那么这个索引也许需要触发更新\r\n        // 如果对应的长度有依赖收集则需要更新\r\n        depsMap.forEach((deps, key) => {\r\n            if (key === 'length' || key >= value) {\r\n                add(deps);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // 对象数组 修改\r\n        if (key !== undefined) { // (数组修改对象的新增修改) 这里对象的新增获取到deps是undefined不会添加到effects中 同时你也没使用到所以不需要触发\r\n            const depsMap = targetMap.get(target);\r\n            const deps = depsMap.get(key);\r\n            add(deps);\r\n        }\r\n        switch (type) {\r\n            case 0 /* ADD */: // 新增  \r\n                if (isArray(target) && isIntegerKey(key)) { // 是数组并且修改是索引 这里需要触发length的更新\r\n                    // 情况是这样的 app.innerHTML = state.arr  这样修改  state.arr[100] = 1\r\n                    add(depsMap.get('length'));\r\n                }\r\n        }\r\n    }\r\n    // 将所有收集到的effect进行执行 更新页面\r\n    effects.forEach((effect) => {\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    });\r\n    // 将deps 添加到effects中\r\n    function add(deps) {\r\n        if (deps) {\r\n            deps.forEach(dep => {\r\n                effects.add(dep);\r\n            });\r\n        }\r\n    }\r\n}\r\nexport { effect, activeEffect, track, trigger };\r\n","references":["/Users/fuzhuoning/Desktop/own/vue3/packages/shared/src/index.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/reactivity/src/operators.ts"]}
