{"code":"// 自定义我们的effect执行策略\r\nconst queue = [];\r\nexport function queueJob(job) {\r\n    if (!queue.includes(job)) { // 对任务进行去重处理\r\n        queue.push(job);\r\n        queueFrush(); // 进行任务队列的刷新\r\n    }\r\n}\r\nlet isFulshing = false; // 是否正在刷新中\r\n// 刷新任务队列 这里的要求是不能频繁的执行\r\nfunction queueFrush() {\r\n    if (!isFulshing) {\r\n        isFulshing = true;\r\n        // 使用微任务来进行异步更新 同步任务执行完毕之后来进行清空任务 \r\n        Promise.resolve().then(flushJobs);\r\n    }\r\n}\r\n// 清空任务\r\nfunction flushJobs() {\r\n    isFulshing = false;\r\n    // 清空时我们需要对job进行排序 根据调用的顺序依次刷新 当父子组件更新的时候 需要先父级更新在子组件进行更新\r\n    // 父组件的effect的id小一些 所以对job进行排序\r\n    queue.sort((a, b) => a.id - b.id);\r\n    for (let i = 0; i < queue.length; i++) {\r\n        const job = queue[i];\r\n        job();\r\n    }\r\n    queue.length = 0;\r\n}\r\n","references":[]}
