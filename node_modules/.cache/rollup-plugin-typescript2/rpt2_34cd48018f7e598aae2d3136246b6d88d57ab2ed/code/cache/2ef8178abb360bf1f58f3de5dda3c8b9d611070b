{"code":"// 组件中所有的方法\r\nimport { isFunction, isObject } from \"@vue/shared\";\r\nimport { publicInstanceProxyHandlers } from \"./componentPublicInstanceProxyHandlers\";\r\n// 创建一个组件实例\r\nexport function createInitialInstance(vnode) {\r\n    // webComponent 组件必备的有属性和插槽\r\n    const instance = {\r\n        vnode,\r\n        type: vnode.type,\r\n        props: {},\r\n        slots: {},\r\n        setupState: {},\r\n        ctx: {},\r\n        isMounted: false,\r\n        render: null\r\n    };\r\n    instance.ctx = { _: instance };\r\n    return instance;\r\n}\r\n// 初始化启动组件\r\nexport function setupComponent(instance) {\r\n    const { props, children } = instance.vnode;\r\n    // 根据props 解析出 props和attrs 更新到instance上\r\n    instance.props = props; // 对应源码中 => initProps\r\n    instance.children = children; // 插槽的解析 => initSlots\r\n    // 判断当前是不是有状态的组件\r\n    const isStateful = instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n    if (isStateful) {\r\n        // 调用实例的setup方法，用setup函数的返回值填充instance的setupState和render\r\n        setupStatefulComponent(instance);\r\n    }\r\n}\r\nfunction setupStatefulComponent(instance) {\r\n    // 1、属性的代理 方便用户访问 传递给render函数的参数  \r\n    // 我什么不直接代理instance 是因为自己需要更新instance上的属性 并不需要走代理\r\n    instance.proxy = new Proxy(instance.ctx, publicInstanceProxyHandlers);\r\n    // 2、获取组件的类型 拿到组件的setup 方法\r\n    const component = instance.type;\r\n    const { setup } = component;\r\n    if (setup) {\r\n        const setupContext = createContext(instance);\r\n        const setupResult = setup(instance.props, setupContext);\r\n        // 主要进行处理setup 返回值\r\n        handleSetupResult(instance, setupResult);\r\n    }\r\n    else {\r\n        finishComponentSetup(instance); // 完成组件的启动\r\n    }\r\n}\r\n// 创建一个组件的上下文\r\nfunction createContext(instance) {\r\n    return {\r\n        attrs: instance.attrs,\r\n        slots: instance.slots,\r\n        emit: () => { },\r\n        expose: () => { }\r\n    };\r\n}\r\n// 完成组件的启动\r\nfunction finishComponentSetup(instance) {\r\n    const component = instance.type;\r\n    let { render } = instance;\r\n    if (!render) {\r\n        if (!component.render && component.template) {\r\n            // 如果没有render则对template模板进行编译产生render函数 将结果赋给component.render \r\n        }\r\n        instance.render = component.render; // 如果组件中有render函数将render函数保存到实例上\r\n    }\r\n}\r\n// 处理setup 返回值\r\nfunction handleSetupResult(instance, setupResult) {\r\n    if (isFunction(setupResult)) { // 如果返回的是一个函数 则将作为render函数\r\n        instance.render = setupResult;\r\n    }\r\n    else if (isObject(setupResult)) { // 如果是对象则将返回的对象更新到setupState上 \r\n        instance.setupState = setupResult;\r\n    }\r\n    finishComponentSetup(instance);\r\n}\r\n","references":["/Users/fuzhuoning/Desktop/own/vue3/packages/shared/src/index.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/runtime-core/src/componentPublicInstanceProxyHandlers.ts"]}
