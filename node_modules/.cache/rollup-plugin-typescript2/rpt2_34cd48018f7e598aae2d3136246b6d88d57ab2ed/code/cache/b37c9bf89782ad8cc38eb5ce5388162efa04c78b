{"code":"import { hasChange, isArray, isObject } from \"@vue/shared\";\r\nimport { reactive } from \".\";\r\nimport { track, trigger } from \"./effect\";\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nconst convert = val => isObject(val) ? reactive(val) : val;\r\nclass RefImpl {\r\n    rawValue;\r\n    isShallow;\r\n    _value; // 表示声明了没赋值\r\n    __v_isRef = true; // 产生的实例会被添加这个属性 表示是一个ref\r\n    constructor(rawValue, isShallow) {\r\n        this.rawValue = rawValue;\r\n        this.isShallow = isShallow;\r\n        this._value = isShallow ? rawValue : convert(rawValue);\r\n    }\r\n    // 使用类的属性访问器 (这里通过babel转义之后就是es5的defineProperty)\r\n    get value() {\r\n        track(this, 0 /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        if (hasChange(newValue, this.rawValue)) {\r\n            this.rawValue = newValue;\r\n            this._value = this.isShallow ? newValue : convert(newValue);\r\n            trigger(this, 1 /* SET */, 'value', newValue);\r\n        }\r\n    }\r\n}\r\n// 创建一个ref\r\nfunction createRef(rawValue, isShallow = false) {\r\n    return new RefImpl(rawValue, isShallow);\r\n}\r\n// 注意由官方文档结果来 并不是RefImpl类的实例 而是这个新类的实例 所以toRef和Ref基本是没有任何关系\r\nclass ObjectRefImpl {\r\n    taget;\r\n    key;\r\n    __v_isRef = true; // 标识是一个ref\r\n    constructor(taget, key) {\r\n        this.taget = taget;\r\n        this.key = key;\r\n    }\r\n    get value() {\r\n        // 注意这里没有响应式 对象是响应式的 代理之后就是响应式的 对象不是响应式的代理之后就不是响应式的\r\n        // 因为这个对象已经是响应式的了 我们通过get和set也是对对象进行修改所以对象的相关依赖和收集和触发 所以这里不需要添加. 只要一層的代理\r\n        return this.taget[this.key];\r\n    }\r\n    set value(newValue) {\r\n        this.taget[this.key] = newValue;\r\n    }\r\n}\r\n// 可以将一个对象的属性变为ref 返回一个ref\r\nfunction toRef(target, key) {\r\n    return new ObjectRefImpl(target, key);\r\n}\r\n// 将一个对象的所有属性都转化为ref\r\nfunction toRefs(target) {\r\n    const res = isArray(target) ? new Array(target.length) : {};\r\n    const keys = Object.keys(target);\r\n    keys.forEach(key => {\r\n        res[key] = toRef(target, key);\r\n    });\r\n    return res;\r\n}\r\nexport { ref, shallowRef, toRef, toRefs };\r\n","references":["/Users/fuzhuoning/Desktop/own/vue3/packages/shared/src/index.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/reactivity/src/index.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/reactivity/src/effect.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/reactivity/src/operators.ts"]}
