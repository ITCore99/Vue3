{"code":"/**\r\n * effect 副作用函数\r\n * 注意effect不仅仅只有一个参数 它还有第二个参数\r\n * effect是响应式的可以做到数据变化 effect 重新执行\r\n */\r\nlet activeEffect = null;\r\nfunction effect(fn, options = {}) {\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) { // lazy 属性为true 说明这个effect 是懒执行的\r\n        effect(); // 默认先执行一次 进行依赖的收集\r\n    }\r\n    return effect;\r\n}\r\nlet uid = 0;\r\n// 创建一个响应式的effect 作用是对effect进行二次的处理 添加一些标识\r\nfunction createReactiveEffect(fn, options) {\r\n    const reactiveEffect = function () {\r\n        fn();\r\n    };\r\n    reactiveEffect.id = uid++; // effect标识 执行更新的时候用此标识对effect进行排序\r\n    reactiveEffect._isEffect = true; // 用于标识这是一个effect\r\n    reactiveEffect.raw = fn; // 保存原始的fn函数\r\n    reactiveEffect.options = options; // 保存options配置项\r\n    return reactiveEffect;\r\n}\r\nexport { effect, activeEffect };\r\n","references":["/Users/fuzhuoning/Desktop/own/vue3/packages/reactivity/src/index.ts"]}
