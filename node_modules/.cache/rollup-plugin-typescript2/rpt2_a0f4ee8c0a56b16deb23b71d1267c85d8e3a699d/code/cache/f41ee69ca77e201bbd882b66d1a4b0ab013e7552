{"code":"import { createAppApi } from \"./apiCreateApp\";\r\nimport { createInitialInstance, setupComponent } from \"./component\";\r\n// 创建一个渲染器 这样写的好处是 如果我们要创建不同的渲染器只需要传递不同的renderOption即可实现\r\nexport function createRenderer(renderOptions) {\r\n    // 挂载组件\r\n    function mountComponent(initialVNode, container) {\r\n        // 组件的渲染流程 核心是调用setup拿到返回值，获取render函数的返回值进行渲染\r\n        // 1、创建一个实例\r\n        const instance = initialVNode.component = createInitialInstance(initialVNode);\r\n        // 2、将需要的数据解析到实例上\r\n        setupComponent(instance); // 初始化组件 将数据全部放到实例上\r\n        // 3、创建一个effect 让render函数执行\r\n        setupRenderEffect();\r\n    }\r\n    // 处理组件\r\n    function processComponent(n1, n2, container) {\r\n        if (n1 === null) { // 进行组件的初始化\r\n            mountComponent(n2, container);\r\n        }\r\n        else { // 进行组件的更新\r\n        }\r\n    }\r\n    // 参数 n1: 老的虚拟节点 n2: 新的虚拟节点 \r\n    function patch(n1, n2, container) {\r\n        // 针对不同的类型做初始化方式\r\n        const { shapeFlag } = n2;\r\n        if (shapeFlag & 1 /* ELEMENT */) { // 是一个元素\r\n            console.log('这是一个元素');\r\n        }\r\n        else if (shapeFlag & 4 /* STATEFUL_COMPONENT */) { // 是一个组件\r\n            processComponent(n1, n2, container);\r\n        }\r\n    }\r\n    // 渲染函数core核心函数\r\n    const render = function (vnode, container) {\r\n        // 根据不同的虚拟节点创建真实的节点\r\n        // 默认进行初始化流程\r\n        patch(null, vnode, container); // 初始化、更新都会使用此方法进行\r\n    };\r\n    return {\r\n        // 这里因为createApp是一个用户可以调用的api所以我们打算再次进行拆分拆到API的文件夹中\r\n        createApp: createAppApi(render)\r\n    };\r\n}\r\n// 框架流程都是将组件 => 虚拟DOM => 真实DOM => 挂载到页面\r\n","references":["/Users/fuzhuoning/Desktop/own/vue3/packages/shared/src/index.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/runtime-core/src/apiCreateApp.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/runtime-core/src/component.ts"]}
