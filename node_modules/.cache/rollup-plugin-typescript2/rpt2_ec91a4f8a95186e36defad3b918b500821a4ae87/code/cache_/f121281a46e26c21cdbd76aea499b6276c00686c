{"code":"/**\r\n * 实现proxy的handlers\r\n * 需要注意的是要判断是不是仅读的 如果是仅读的话 在进行set是时候要进行报异常处理\r\n * 判断是是不是深度的\r\n */\r\nimport { isObject, extend } from \"@vue/shared\";\r\nimport { reactive, readonly } from \".\";\r\n// 创建一个getter\r\nfunction createGetter(isReadonly = false, isShallow = false) {\r\n    return function (target, key, receive) {\r\n        const res = Reflect.get(target, key, receive);\r\n        if (!isReadonly) {\r\n            // 如果不是仅读 要收集依赖\r\n        }\r\n        if (isShallow) {\r\n            return res;\r\n        }\r\n        if (isObject(res)) {\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst get = createGetter(false, false);\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true, false);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\n// 创建一个setter\r\nfunction createSetter(isShallow = false) {\r\n    return function (target, key, value, receive) {\r\n        const res = Reflect.set(target, key, value, receive);\r\n        if (!isShallow) {\r\n            // 进行依赖触发\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\n// 仅读对象\r\nconst readonlyObj = {\r\n    set(target, key, value) {\r\n        console.log(`set on key ${key} is fail, because is readonly`);\r\n    }\r\n};\r\nconst mutableHandlers = {\r\n    get,\r\n    set\r\n};\r\nconst shallowReactiveHandlers = {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n};\r\nconst readonlyHandlers = extend({\r\n    get: readonlyGet,\r\n}, readonlyObj);\r\nconst shallowReadonlyHandlers = extend({\r\n    get: shallowReadonlyGet,\r\n}, readonlyObj);\r\nexport { mutableHandlers, shallowReactiveHandlers, readonlyHandlers, shallowReadonlyHandlers };\r\n","references":["/Users/fuzhuoning/Desktop/own/vue3/packages/shared/src/index.ts","/Users/fuzhuoning/Desktop/own/vue3/packages/reactivity/src/index.ts"]}
