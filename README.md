# Vue2和Vue3相关知识

## 性能优化

### 1、静态节点提升

- 每次重新渲染 都要创建虚拟节点 createVnode 这个方法
- 静态变量节点提升 “静态节”点进行提取 除了第一次需要创建之后的更新流程就不需要进行创建虚拟节点而是使用之前提升的节点 
- 如果数目过多的静态节点会进行合并为一个虚拟节点进行提升(超过20个节点 => 最终只会生成一个节点)

### 2、事件缓存

- 缓存事件防止重新创建事件（就是我们在pathEvent中进行的缓存优化通过_vei属性进行缓存）

> jsx 目的是为了灵活 （但是没有优化）

## Vue3 和 Vue2的对比

- 响应式原理 proxy - defineProperty
- Vue3 的diff算法(根据 patchFlag 做diff 知道那个类名 那个属性变化了 去针对的更新， 同时使用最常递增子序列找到最常不需要移动的序列优化使用dom 提高性能) 和 Vue2 (全量diff)
- compositionApi 将代码按照功能拆分 可以提取为函数方便复用 / options APi 需要将变量函数写到不同的位置 避免了过多的属性绑定到this上 方便进行tree-sharking
- Fragment 多个根节点支持 Teleport 传送门 Suspense 异步组件
- Vue3 ts -> Vue flow 相比更好的推断
- 自定义渲染器 createRenderer() 传入自己渲染的方法 好处是可以根据vue 核心来实现不同平台代码
- 采用monorepo代码管理方式
- 模板编译优化 静态节点提升、事件缓存

## Vue3模板编译和Vue2模板编译有什么区别

> 编译流程:

- 对模板进行分析(词法分析生成token流 语法分析) => 生成ast树(就是一个对象用来描述语法本身)
- 做转化流程transform 主要是对动态节点进行标记 比如 指令 插槽 事件 属性  (即就是添加pathFlag)
- 代码生成 codegen -> 生成最终的代码

> block的概念：

- block的作用: 就是收集动态节点 (它自己下面所有的) 将树的递归拍平成了一个数组(dynamicChildren) 在进行比对的时候只需要比对收集的这个数组 不需要递归比对虚拟节点children 提高性能
在进行createVnode创建虚拟节点的时候会判断这个节点是不是动态的 如果是动态的话我们就需要让外层的block对其进行收集起来(在createVNode 虚拟节点的时候 进行判断收集)

- diff 算法的特点 就是递归遍历 每次比较同一层 之前写全量比对
- block进行收集了动态节点之后就会将树的不同层级孩子的递归拍平成一个数组
- 在createVnode的时候进行 判断这个节点是不是动态的 如果是就让外层的block收集起来
- 目的是为了diff的时候只会diff动态的节点
- 如果会影响结构的都会被标记成block 比如v-if、v-for、 v-if key: 1 v-else key:2 可以不相同则不用diff比对 这样的话是没法进行优化
- 父亲也会收集儿子的block 最终行程一个block tree
- 改变结构的也要封装到block中 我们期望的更新方式是拿以前的和现在的去比对，靶向更新 如果前后节点个数不一致那只能全部diff比对（不进行收集动态节点）

## patchFlags 对不同动态节点进行描述

> 表示要比对哪些类型
